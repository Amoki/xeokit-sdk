<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>xeokit Example</title>
    <link href="../css/pageStyle.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script>
    <style>
        #lensContainer {
            border: 1px black solid;
            width: 300px;
            height: 300px;
            position: absolute;
            border-radius: 50%;
            z-index: 15000;
            background: darkblue;
            overflow: hidden;
            pointer-events: none;
            margin-top: 85px;
            margin-left: 25px;
            /*display: none;*/
        }

        #lens {
            width: 300px;
            height: 300px;
            background: lightblue;
            z-index: 15002;
            pointer-events: none;
        }
    </style>
</head>
<body>
<input type="checkbox" id="info-button"/>
<label for="info-button" class="info-button"><i class="far fa-3x fa-question-circle"></i></label>
<canvas id="myCanvas"></canvas>
<div id="lensContainer">
    <canvas id="lens" width="300" height="300"></canvas>
</div>
<div class="slideout-sidebar">
    <h1>Snap-to-vertex</h1>
    <h2>Hover over model to snap pointer to the nearest vertex</h2>
    <p>This page demonstrates a technique developed by <a href="https://github.com/tmarti">Toni Marti</a>, where we use
        a lens to help position the pointer as
        we snap it to the nearest vertex.</p>
    <h3>Components used</h3>
    <ul>
        <li>
            <a href="../../docs/class/src/viewer/Viewer.js~Viewer.html"
               target="_other">Viewer</a>
        </li>
        <li>
            <a href="../../docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html"
               target="_other">XKTLoaderPlugin</a>

        </li>
    </ul>
    <h3>Resources</h3>
    <ul>
        <li>
            <a href="https://github.com/openBIMstandards/DataSetSchependomlaan"
               target="_other">Model source</a>
        </li>
    </ul>
</div>
</body>

<script type="module">

    //------------------------------------------------------------------------------------------------------------------
    // Import the modules we need for this example
    //------------------------------------------------------------------------------------------------------------------

    import {Viewer, XKTLoaderPlugin, DistanceMeasurementsPlugin} from "../../dist/xeokit-sdk.es.js";

    //------------------------------------------------------------------------------------------------------------------
    // Create a Viewer, arrange the camera
    //------------------------------------------------------------------------------------------------------------------

    const viewer = new Viewer({
        canvasId: "myCanvas",
        transparent: true, // Default
        preserveDrawingBuffer: true // Default - needed true for canvas screenshots
    });

    viewer.camera.eye = [-3.933, 2.855, 27.018];
    viewer.camera.look = [4.400, 3.724, 8.899];
    viewer.camera.up = [-0.018, 0.999, 0.039];

    //------------------------------------------------------------------------------------------------------------------
    // Create a DistanceMeasurementsPlugin
    //------------------------------------------------------------------------------------------------------------------

    const distanceMeasurements = new DistanceMeasurementsPlugin(viewer, {});

    distanceMeasurements.control.activate();

    //----------------------------------------------------------------------------------------------------------------------
    // Load a model and fit it to view
    //----------------------------------------------------------------------------------------------------------------------

    const xktLoader = new XKTLoaderPlugin(viewer);

    const sceneModel = xktLoader.load({
        id: "myModel",
        src: "../../assets/models/xkt/v10/glTF-Embedded/Duplex_A_20110505.glTFEmbedded.xkt",
        edges: true
    });

    //------------------------------------------------------------------------------------------------------------------
    // Lens widget
    //------------------------------------------------------------------------------------------------------------------

    const lensCursorDiv = document.createElement('div');
    viewer.scene.canvas.canvas.parentNode.insertBefore(lensCursorDiv, viewer.scene.canvas.canvas);
    lensCursorDiv.style.background = "greenyellow";
    lensCursorDiv.style.border = "2px solid green";
    lensCursorDiv.style.borderRadius = "20px";
    lensCursorDiv.style.width = "10px";
    lensCursorDiv.style.height = "10px";
    lensCursorDiv.style.margin = "-200px -200px";
    lensCursorDiv.style.zIndex = "100000";
    lensCursorDiv.style.position = "absolute";
    lensCursorDiv.style.pointerEvents = "none";

    const lensContainer = document.getElementById("lensContainer");
    const lensCanvas = document.getElementById("lens");
    const lensCanvasContext = lensCanvas.getContext('2d');
    const canvasElement = viewer.scene.canvas.canvas;

    let lastCoords = null;
    let lastSnapCoords = null;
    let lensPosToggle = true;

    const setLensCenterAt = (coords) => {
        lastCoords = coords;
    }

    const setLensSnapCursorAt = (coords) => {
        lastSnapCoords = coords;
    }

    const refreshLens = () => {
        if (!lastCoords) {
            return;
        }
        const lensRect = lensContainer.getBoundingClientRect();
        const canvasRect = canvasElement.getBoundingClientRect();
        const pointerOnLens =
            lastCoords[0] < lensRect.right && lastCoords[0] > lensRect.left &&
            lastCoords[1] < lensRect.bottom && lastCoords[1] > lensRect.top;
        lensContainer.style.marginLeft = `25px`;
        if (pointerOnLens) {
            if (lensPosToggle) {
                lensContainer.style.marginTop = `${canvasRect.bottom - canvasRect.top - lensCanvas.height - 85}px`;
            } else {
                lensContainer.style.marginTop = `85px`;
            }
            lensPosToggle = !lensPosToggle;
        }
        const zoomLevel = 2;
        lensCanvasContext.clearRect(0, 0, lensCanvas.width, lensCanvas.height);
        const size = Math.max(lensCanvas.width, lensCanvas.height) / zoomLevel;
        lensCanvasContext.drawImage(
            canvasElement, // source canvas
            lastCoords[0] - size / 2, // source x (zoom center)
            lastCoords[1] - size / 2, // source y (zoom center)
            size, // source width
            size, // source height
            0, // destination x
            0, // destination y
            lensCanvas.width, // destination width
            lensCanvas.height // destination height
        );

        const centerLensCanvas = [
            (lensRect.left + lensRect.right) / 2,
            (lensRect.top + lensRect.bottom) / 2
        ];

        if (lastSnapCoords) {
            const deltaX = lastSnapCoords[0] - lastCoords[0];
            const deltaY = lastSnapCoords[1] - lastCoords[1];

            lensCursorDiv.style.marginLeft = `${centerLensCanvas[0] + deltaX * zoomLevel - 10}px`;
            lensCursorDiv.style.marginTop = `${centerLensCanvas[1] + deltaY * zoomLevel - 10}px`;

            lensCursorDiv.style.background = "greenyellow";
            lensCursorDiv.style.border = "2px solid green";
        } else {
            lensCursorDiv.style.marginLeft = `${centerLensCanvas[0] - 10}px`;
            lensCursorDiv.style.marginTop = `${centerLensCanvas[1] - 10}px`;

            lensCursorDiv.style.background = "pink";
            lensCursorDiv.style.border = "2px solid red";
        }
    }

    viewer.scene.on("rendering", ()=>{
        refreshLens();
    });


    //------------------------------------------------------------------------------------------------------------------
    // Mouse hover to snap to vertices
    //------------------------------------------------------------------------------------------------------------------

    // const canvasCursorDiv = document.createElement('div');
    // viewer.scene.canvas.canvas.parentNode.insertBefore(canvasCursorDiv, viewer.scene.canvas.canvas);
    // canvasCursorDiv.style.background = "black";
    // canvasCursorDiv.style.border = "2px solid blue";
    // canvasCursorDiv.style.borderRadius = "20px";
    // canvasCursorDiv.style.width = "10px";
    // canvasCursorDiv.style.height = "10px";
    // canvasCursorDiv.style.margin = "-200px -200px";
    // canvasCursorDiv.style.zIndex = "100000";
    // canvasCursorDiv.style.position = "absolute";
    // canvasCursorDiv.style.pointerEvents = "none";

    function pointerMoved(canvasPos) {
        const snapPickResult = viewer.scene.snapPick({
            canvasPos,
            snapRadius: 30,
            snapMode: "vertex",
        });
        if (snapPickResult && snapPickResult.snappedCanvasPos) {
            // canvasCursorDiv.style.marginLeft = `${snapPickResult.snappedCanvasPos[0] - 10}px`;
            // canvasCursorDiv.style.marginTop = `${snapPickResult.snappedCanvasPos[1] - 10}px`;
            // canvasCursorDiv.style.background = "greenyellow";
            // canvasCursorDiv.style.border = "2px solid green";
            setLensCenterAt(snapPickResult.snappedCanvasPos);
            setLensSnapCursorAt(snapPickResult.snappedCanvasPos);
        } else {
            // canvasCursorDiv.style.marginLeft = `${canvasPos[0] - 10}px`;
            // canvasCursorDiv.style.marginTop = `${canvasPos[1] - 10}px`;
            // canvasCursorDiv.style.background = "pink";
            // canvasCursorDiv.style.border = "2px solid red";
            setLensCenterAt(canvasPos);
            setLensSnapCursorAt(null);
        }
        refreshLens();
    }

    function mousePointerMoved(event) {
        event.preventDefault();
        const canvasPos = [event.clientX, event.clientY];
        pointerMoved(canvasPos);
    }

    document.addEventListener("mousemove", mousePointerMoved);

</script>
</html>
